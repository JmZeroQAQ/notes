### 1. 为什么我们要写容易被编译器优化的代码？

1.1 更容易被编译器优化的代码便意味着编译出来后的程序有更加高效的性能。

1.2 编译器的优化能力是有局限性的，编译器必须保证优化后的程序和优化前的程序具有一致的行为，所以无法做一些我们看起来没有问题的优化。

1.3 虽然编译器给我们提供了不同的优化等级，比如`-Og -O1 -O2` 甚至 `-O3`。但是使用更高等级的优化不仅会使编译出的汇编代码很难和源代码对应的上，还会让`gdb` 和 `程序剖析工具` 难以正常执行。

### 2. 了解编译器的优化局限
#### 2.1 内存别名使用

首先先了解一下什么是内存别名使用，内存别名使用是指：两个指针可能指向同一个内存位置的情况。

考虑下面两段代码：

```c
void twiddle1(long *xp, long *yp) {
    *xp += *yp;
    *xp += *yp;
}

void twiddle2(long *xp, long *yp) {
    *xp += 2 * (*yp);
}
```

乍一看这两段代码似乎在做一样的事情，都是加两次 `*yp` 到 `*xp` 上，并且我们可以发现，显然是 `twiddle2` 函数的效率更高，因为`twiddle2`涉及到的内存引用次数明显比`twiddle1`更少。`twiddle2`需要`3`次，而`twiddle1`需要`6`次。

那我们的编译器能否将 `twiddle1` 优化成 `twiddle2`？请注意，我这里说的 **优化成** 是指将 `twiddle1`使用高等级优化后产生的汇编代码再将其翻译成对应的`c`代码。答案是不能的，因为编译器无法判断 `xp` 和 `yp`所引用的地址是否相等。

考虑`xp`和`yp`引用地址相等的情况：
1. 对于 `twiddle1`，设`*xp = *yp = x` `twiddle1` 最后得出的结果应该是: `4x`

2. 对于 `twiddle2`，设`*xp = *yp = x` `twiddle2` 最后得出的结果应该是: `3x`

我们可以发现两个函数的结果并不一致。编译器需要保证优化后程序的行为与优化前程序的行为一致，但是因为编译器无法判断内存别名使用的情况，所以无法进行这种优化。即使我们可以保证我们的程序并不会有内存别名使用的情况。
#### 2.2 函数调用

函数调用也会影响编译器进行优化。考虑下面代码：

```c
long f();

long func1() {
    return f() + f() + f() + f();
}

long func2() {
    return 4 * f();
}
```

在我们看来，这两段代码做的依然是一样的事情，都是返回`4 * f()` 的值，那编译器能否将`func1()`优化成`func2()`呢？因为进行函数调用(过程调用)也是有成本的，而`func2()`只进行了`1`次函数调用。答案是依旧不能，因为编译器不会去判断函数`f()`是否有副作用。

**我们可以简单的将函数副作用理解为：这个函数修改了函数外的变量。**

假如函数`f()`的代码定义为以下内容:
```c
long global_counter = 0;

long f() {
    return global_counter++;
}
```

那么函数`func1()`和函数`func2`的结果就不一致了。因为编译器不会去判断一个函数是否有副作用，所以我们不能指望编译器会帮我们将`func1()`优化成`func2()`。我们必须手动进行这样的优化。