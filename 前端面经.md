### 机试
1. 去重 PASS
2. 防抖 PASS
3. 深拷贝 PASS
4. 括号匹配
5. 创建一个导航栏，鼠标停留在上面有相应的样式变化
6. 实现一个轮播图
7. CSS超出文字显示省略号 PASS
8. 判断两个对象是否相等 PASS

### 八股

1. bind是什么，如何实现 PASS
2. let var const 的区别 PASS
3. 箭头函数和普通函数的区别 PASS
4. React生命周期
5. React Hooks
6. ES6 新特性 PASS
7. 类组件和函数式组件的区别
8. localstorage, session storage, cookie的区别 PASS
9. JS原型链是什么， 原型对象是什么 PASS
10. http缓存机制 PASS
11. CSS选择器 PASS
12. promise， promise.all防抖 PASS
13. http 和 https的区别
14. 实现水平居中，垂直居中的办法 PASS
15. css position属性 PASS
16. css 盒模型 PASS
17. css文字超出显示省略号 PASS
18. setState是同步的还是异步的
19. 是什么事件循环 PASS
20. flex布局 PASS
21. 什么是浏览器回流(reflow)和重绘制(repaint) PASS
22. 响应式布局的实现 PASS
23. 什么是盒模型 PASS
24. js数据类型有哪些 PASS
25. 浏览器缓存机制 PASS
26. 懒加载
27. 虚拟列表是什么 PASS
28. React use memo
29. 语义化标签有哪些 PASS
30. 浏览器渲染过程 PASS
31. rem实现响应式 PASS
32. md5是什么，长度固定吗 PASS
33. axios PASS
34. redux 和 zustand
35. async, await, promise的区别  PASS
36. js数组和字符串的常用操作 PASS
37. Object, Array有哪些j静态方法
38. 从键入url到网页加载完成发生了啥 PASS
39. script标签和link标签常用属性

箭头函数和普通函数的区别
```js
普通函数可以使用arguments对象访问所有传入的参数,箭头函数不行

普通函数有prototype属性,可以实现继承,箭头函数没有

普通函数的this在函数调用时确定，根据调用方式的不同有不同的结果
1. 普通调用，this指向全剧对象window
2. 方法调用，this指向该方法的对象

// 箭头函数的this在定义时确定,继承外层作用域的this,无法通过call, apply, bind改变
const obj = {
  name: "alice",
  greet: () => {
    console.log(this.name);
  },
};

console.log(obj.greet()); // undefined

// bind,函数对象的方法,返回一个函数,这个函数的this被永久绑定到指定的对象,无法被改变
// 也可也用bind绑定参数
const obj = {
  name: "alice",
};

function greet() {
  console.log(this.name);
}

// bind 返回将this替换成obj的新函数
newGreet = greet.bind(obj);

newGreet(); // output: "alice"
greet.call(obj); // output: "alice"
greet.apply(obj); // output: "alice"
```

var, let, const 的区别
```js
// var 函数作用域
// let, const, 块级作用域, 更加精细

console.log(x); // 直接报错
let x = 10;

console.log(y); // 输出undefined
var y = 20;

// var 在全局作用域声明,会变成全局对象,成为windows对象的成员, let不会
// var 可以重复声明,但是let不行
```

JS有哪些变量类型
```js
number
string
boolean
undefined
null
symbol // 表示唯一的,不可变的值,通常用作对象属性的键

let sym1 = Symbol('key');
let sym2 = Symbol('key');
console.log(sym1 === sym2); // false，每个 Symbol 都是唯一的

bigint


object
array
function
map
set
promise


typeof, instanceof, Object.prototype.toString

console.log(typeof 42); // 'number'
console.log(typeof 'hello'); // 'string'
console.log(typeof true); // 'boolean'
console.log(typeof undefined); // 'undefined'
console.log(typeof null); // 'object'（历史遗留问题）
console.log(typeof Symbol('key')); // 'symbol'
console.log(typeof 123n); // 'bigint'
console.log(typeof {}); // 'object'
console.log(typeof []); // 'object'
console.log(typeof function() {}); // 'function'

console.log([] instanceof Array); // true
console.log({} instanceof Object); // true
console.log(new Date() instanceof Date); // true

console.log(Object.prototype.toString.call(42)); // '[object Number]'
console.log(Object.prototype.toString.call('hello')); // '[object String]'
console.log(Object.prototype.toString.call([])); // '[object Array]'
console.log(Object.prototype.toString.call(null)); // '[object Null]'
```

Proxy, prototype对象
```js
// Proxy对象用于实现对象代理
// prototype对象用于实现继承机制

const target = {
  name: "Alice",
  age: 25,
};

// handler也是一个对象,需要定义陷阱函数(trap function)
// 常见的陷阱函数有: get, set, has, deleteProperty, apply, construct
const handler = {
  get(target, prop) {
    console.log(`访问属性: ${prop}`);
    return target[prop];
  },
  set(target, prop, value) {
    console.log(`设置属性: ${prop} = ${value}`);
    target[prop] = value;
    return true; // 表示设置成功
  },
};

const proxy = new Proxy(target, handler);

console.log(proxy.name); // 访问属性: name → "Alice"
proxy.age = 30; // 设置属性: age = 30
console.log(proxy.age); // 访问属性: age → 30


// 当访问对象的属性或方法时，如果对象本身没有该属性，JavaScript 会沿着原型链向上查找，直到找到该属性或到达原型链的末端（`null`）。
// 原型链的顶端是 `Object.prototype`。
```

事件循环
JavaScript 是单线程的，这意味着它一次只能执行一个任务。如果所有任务都是同步的，那么一个耗时的任务（如网络请求或复杂计算）会阻塞整个程序的执行。为了解决这个问题，JavaScript 引入了**异步任务**和**事件循环**机制。
```js
// 事件循环的核心思想是: 将任务分为同步任务和异步任务,异步任务又分为宏任务和微任务,事件循环会不断的检查任务队列(从队头取出元素),按照一定的规则执行任务.

// 事件循环的流程:
// 1. 先执行同步任务,从调用栈中依次执行同步任务
// 2. 当调用栈为空时,从微任务队列取出所有任务执行
// 3. 从宏任务队列取出一个任务执行
// 4. 执行完成后,再次检查微任务队列并执行所有微任务
// 5. 从头重复流程
```

Promise
```js
// 接受一个执行器函数作为参数,该函数有两个参数: resolve, reject
// resolve: 将Promise对象的状态改为 fulfield, 并传递结果值
// reject: 将Promise对象状态改为rejected, 并传递原因
// 状态: pending, fulfield, rejected
new Promise((resolve, reject) => {
 // 异步操作
})

// .then()
// 用于注册Promise状态为fulfield或rejected时的回调函数
// 就受两个参数: onFulfilled, Promise成功时调用的函数; onRejected, Promise失败时调用的函数（可选）。

// .catch
// 是 `.then(null, onRejected)` 的语法糖。

// .finally()
// 用于注册一个回调函数，无论 `Promise` 成功还是失败都会执行。

// Promise的静态方法
// Promise.resolve(): 返回一个状态为fulfiled的Promise对象
// Promise.reject(): 返回一个状态为rejected的Promise对象

// Promise.all():
// 接收一个Promise对象的数组,返回一个新的Promise
// 当所有Promise都成功时,返回的结果是一个数组,包含所有Promise的结果
// 如果有一个Promise失败,则立即返回失败的原因

// Promise.race()
// 接受一个Promise数组,返回一个新的Promise,返回第一个成功或者是失败的结果

// Promise.allSettled():
// 接受一个Promise数组,返回一个新的Promise,当所有Promise都完成时(无论成功还是失败),返回一个数组,包含结果或错误原因

// Promise.any():
// 类似Promise.race(),但是只返回第一个成功的结果,若全部失败,返回AggregateError
```

async, await
```js
// 用于声明异步函数,异步函数会自动返回一个Promise对象
// Promise的语法糖
async function foo() {
  // 如果xxx是非Promise对象,则自动使用Promise.resolve(xxx)包装
  // 如果函数执行过程中抛出错误,则返回Promise.reject(error)
  return xxx;
}

// await只能在异步函数内使用, 用于等待某个Promise对象完成执行(fulfield or rejected)
// 在异步函数使用await,相当于把await之后的语句都变成了 微任务

async function foo() {
  console.log("start execute foo");
  res = await new Promise((resolve) => {
    setTimeout(() => {
      console.log("work finished");
      resolve(100);
    }, 2000);
  });

  console.log("res: ", res);
  console.log("finishing execute foo");
  return 111;
}

function main() {
  console.log("start execute main");

  r = foo();
  console.log(r);

  console.log("finishing execute main");
}

main();

// 结果:
// start execute main
// start execute foo
// Promise {<pending>}
// finishing execute main
// 等待两秒
// work finished
// res:  100
// finishing execute foo
```


AXIOS
```js
// 一个基于Promise的HTTP客户端

// get请求
axios.get('https://api.example.com/data')
  .then((response) => {
    console.log(response.data); // 响应数据
  })
  .catch((error) => {
    console.error(error); // 错误处理
  });

// post请求
axios.post('https://api.example.com/data', {
    name: 'Alice',
    age: 25
  })
  .then((response) => {
    console.log(response.data);
  })
  .catch((error) => {
    console.error(error);
  });
```


MD5是一个哈希函数,用于将任意长度数据映射为一个固定长度的哈希值(16字节)
常见使用场景:
1. 数据完整性校验
2. 生成唯一标识

ES6新特性
```js
// 1. let, const
// 2. 箭头函数
// 3. 模板字符串
// 4. 解构赋值
const [a, b] = [1, 2];
console.log(a, b);

const { name, age } = { name: "alice", age: 25 };
// 5. 默认参数
function greet(name = 'Guest') {
  console.log(`Hello, ${name}!`);
}
greet(); // Hello, Guest!

// 6. 剩余参数
function sum(...numbers) {
  return numbers.reduce((acc, num) => acc + num, 0);
}
console.log(sum(1, 2, 3)); // 6
// 7. 扩展运算符
const arr1 = [1, 2];
const arr2 = [3, 4];
const combined = [...arr1, ...arr2];
console.log(combined); // [1, 2, 3, 4]
// 8. 类
// 9. 模块化
// 10. Promise
// 11. Symbol
// 12. 迭代器,生成器
// 13. Map, Set
// 14. Proxy
// 15. Reflect
// 16. for of 循环
// 17. Array的新方法
// 18. Object的新方法
// 19. String的新方法
```

js数组和字符串的常用操作:
```js
let arr = [1, 2];
let a = new Array(1, 2);

// 判断是否相等
console.log(Array.toString(arr) == Array.toString(a));

arr.push(3); // 尾部压入, 相反操作为pop
arr.unshift(0); // 头部压入, 相反操作为shift

console.log(arr); // [0, 1, 2, 3]

// 从索引1开始删除两个元素然后插入10
arr.splice(1, 2, 10);
console.log(arr); // [0, 10, 3]

// 截取数组[1, 2)范围内的元素
console.log(arr.slice(1, 2)); // [10]
// 返回元素的索引(不存在返回 -1)
console.log(arr.indexOf(10)); // 1
// 检查是否包含某个元素
console.log(arr.includes(10)); // true
// 返回符合条件的第一个元素
console.log(arr.find((n) => n > 5)); // 10

// 遍历数组
// arr = [0, 10, 3]
arr.forEach((num) => {
  console.log(num);
});

console.log(arr.map((num) => num * 2)); // [0, 20, 6]
console.log(arr.filter((num) => num > 0)); // [10, 3]
console.log(arr.reduce((acc, num) => (acc += num))); // 13

// 排序和反转
arr.sort(); // 不传入参数默认是将元素转化成字符串按字典序升序排序
let sorted = arr.sort((a, b) => a - b);
console.log("sorted: ", sorted);
console.log(arr.reverse());

// 将元素拼接成字符串
console.log(arr.join(",")); // [3, 10, 0]


// 字符串
let str = "hello world";

// 返回字符串的索引
console.log(str.indexOf("llo")); // 2
// 检查是否包含字符串
console.log(str.includes("hello")); // true
// 检查是否以指定字符串开头
console.log(str.startsWith("hello")); // true
// 检查是否以指定字符串结尾
console.log(str.endsWith("world")); // true

// 返回指定范围的字串
console.log(str.slice(1, 5)); // ello

// 替换
console.log(str.replace("world", "javascript"));

// 去除空白字符
console.log("  asd  ".trim()); // asd
// 还有 trimStart, trimEnd

```

js可比较类型:
```js
// == 宽松比较, 比较值是否相等,会自动进行类型转换
// === 严格比较, 如果是对象,会比较对象的引用地址,只有两个变量引用同一个对象才会为true

// 基本类型可比较:
// number, string, boolean, null, undefined, bigint, symbol

NaN == NaN // false
// 使用Number.isNaN()判断是否为NaN

// 如何比较对象? 手写比较函数
```

虚拟列表:
```js
// 当处理大量列表的时候,浏览器会为每个列表条目都创建dom元素,导致性能问题
// 虚拟列表就是只渲染可见位置视窗范围内的列表,然后填充空白区域保持滚动条位置
```

CSS选择器
基本选择器:
- 元素选择器
- 类选择器
- id选择器
组合选择器:
```css
祖先元素 后代元素 {
  样式规则;
}

父元素 > 子元素 {
  样式规则;
}

元素 + 相邻兄弟元素 {
  样式规则;
}

元素 ~ 兄弟元素 {
  样式规则;
}
```
属性选择器:
```css
// 存在属性选择器
元素[属性] {
  样式规则;
}

// 属性值选择器
元素[属性="值"] {
  样式规则;
}

// 属性值前缀选择器
元素[属性^="值"] {
  样式规则;
}

// 属性值后缀选择器
元素[属性$="值"] {
  样式规则;
}

// 属性值包含选择器
元素[属性*="值"] {
  样式规则;
}
```

伪类选择器:
```css
// 动态伪类
:hover
:active
:focus

// 结构伪类
:first-child // 选择第一个子元素
:last-child // 选择最后一个子元素
:nth-child(n) // 选择第n个子元素
:nth-last-child(n) // 选择倒数第n个子元素

// 其他伪类
:not(选择器) // 选择不符合括号内选择器的元素
:empty // 选择没有子元素的元素
```
伪元素选择器:
```css
::before // 在元素内容之前插入内容
::after // 在元素内容之后插入内容
::first-line // 选择元素的第一行文本
::first-letter // 选择元素的第一个字母
```

选择器优先级:
```css
1. important!
2. 内联样式
3. id选择器
4. 类选择器,属性选择器,伪类选择器
5. 元素选择器,伪元素选择器
6. 通配符选择器
```

实现水平居中，垂直居中的方法：
水平居中:
```css
// 文本
text-align: center;

// 块元素
margin: 0 auto;

// 父元素设置flex布局:
display: flex;
justify-content: center;

// 父元素设置grid布局
display: grid;
justify-content: center;
```
竖直居中
```css
// 文本
line-height: height;

// 父元素使用flex布局
display: flex;
align-items: center;

// 父元素使用grid布局
display: flex;
align-items: center;

// 父元素使用position: relative
// 子元素使用:
position: absolute;
top: 0;
bottom: 0;
margin: auto

// 对于inline-block元素,可以设置父容器为:
vertical-align: middle;
```

CSS position属性
```css
// 控制元素在文档(dom)中的定位方式

// static: 默认布局,即元素在文档常规流中当前的布局位置。此时 top, right, bottom, left 和 z-index 属性无效。
// relative: 该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。top, right, bottom, left等调整元素相对于初始位置的偏移量。
// absolute: 元素会被移出正常文档流，并不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。
// fixed: 元素会被移出正常文档流，并不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。
// sticky: 粘性定位可以被认为是相对定位和固定定位的混合。元素在跨越特定阈值前为相对定位，之后为固定定位。。
```

CSS盒模型:
```css
// CSS 中的 box-sizing 属性定义了 user agent 应该如何计算一个元素的总宽度和总高度。
// content-box：是默认值，设置border和padding均会增加元素的宽高。
box-sizing: content-box;

// border-box：设置border和padding不会改变元素的宽高，而是挤占内容区域。
box-sizing: border-box;
```


css超出文字显示省略号:
```css
// 没有滚动条显示省略号
overflow: hidden;
text-overflow: ellipsis;

// 有滚动条显示省略号
overflow: auto;
text-overflow: ellipsis;
```

css flex布局
```css
// 定义元素如何在flex容器内排列,可选值有: row, row-reverse, column, column-reverse.
flex-direction:

// 是否允许换行,可选值: nowrap, wrap, wrap-reverse
flex-wrap

// flex-start：默认值。左对齐。
// flex-end 右对齐
// space-between 左右两端对齐
// space-around 行首尾部到两端的距离是元素间距离一半
// space-evnely 行首尾部到两端的距离是元素间距离相同
justify-content:

// 设置flex容器内元素在侧轴的排列
align-items: [center, flex-start, flex-end, strenth]

// 默认值为0,flex内子元素设置,表明自己占几份flex容器长度
// 假如设置了为x,那么就占 (x / 所有子元素设置之和)份
flex-grow: [0, 1, 2, ...]

// 设置收缩比例
flex-shrink: [0, 1, 2, ...]

// 默认为auto, 设置子元素的占据flex布局的基础大小
flex-basis: [length]

// flex容器内元素设置,设置为2意味着排在第二
order: [1, 2, 3]
```

响应式布局的实现:
- 使用框架,如tailwind css
- 使用媒体查询
- 使用flex或grid布局
- 使用相对单位
```css
/* 当屏幕宽度小于 600px 时应用的样式 */
@media (max-width: 600px) {
  body {
    background-color: lightcoral;
  }
}
/* 当屏幕宽度大于 600px 小于 1200px 时应用的样式 */
@media (min-width: 600px) and (max-width: 1200px) {
  body {
    background-color: lightgreen;
  }
}
```

什么是浏览器回流(reflow)和重绘制(repaint)

浏览器渲染流程:
1. 解析HTML,生成DOM树
2. 解析CSS,生成CSSOM树
3. 结合DOM和CSSOM,生成渲染树
4. 计算布局,计算每个节点在屏幕上的确切位置和大小
5. 绘制,将布局计算后的结果绘制到屏幕上

```js
// 回流(Reflow)：重新计算元素的几何属性，代价较高。
// 重绘(Repaint)：重新绘制元素，代价较低。

// 回流一定会触发重绘：因为回流改变了元素的几何属性，浏览器需要重新绘制。
// 重绘不一定触发回流：如果只是改变颜色等不影响布局的属性，则只会触发重绘。
```

语义化标签有哪些:
语义化标签的优点:
语义化标签使得HTML代码更具可读性和可维护性，同时也有助于搜索引擎优化（SEO）和辅助技术的使用。
```html
<header>
<footer>
<nav>
<main>
<artive>
<section>
<aside>
.
.
.
```

浏览器缓存:
浏览器缓存分为：强缓存和协商缓存，当强缓存失效时，浏览器会使用协商缓存。
服务器响应头设置客户端的缓存行为。

客户端设置请求头发送请求，根据相应判断本地缓存是否可用
```
304 Not Modified

强缓存响应头：
Cache-Control
Expires
```

防抖，节流：
```js
function debounce(fn, delay) {
  let t = null;

  return function () {
    if (t !== null) {
      clearTimeout(t);
      t = null;
    }

    t = setTimeout(() => {
      fn();
    }, delay);
  };
}

function throttle(fn, delay) {
  let t = true;

  return function () {
    if (t) {
      t = false;
      setTimeout(() => {
        fn();
        t = true;
      }, delay);
    }
  };
}

let btn = document.querySelector(".btn");
btn.onclick = throttle(() => {
  console.log("hhhh");
}, 1000);

```

deepCopy
```js
function deepCopy(obj) {
  if (obj == null) {
    return null;
  }

  let newObj = {};
  for (let k in obj) {
    if (typeof obj[k] == "object") {
      newObj[k] = deepCopy(obj[k]);
    } else {
      newObj[k] = obj[k];
    }
  }

  return newObj;
}

let a = {
  name: "alice",
  age: 12,
  info: {
    addr: "xxx.xxx.xxx",
    email: "xxx@xx.com",
  },
};

let b = deepCopy(a);
console.log(b);

```


从键入url到网页加载完成发生了啥
1. 键入URL
2. DNS解析
3. 建立TCP连接
4. 开始通信

HTTP状态码
```
200 OK 成功状态码
204 NOT Content 成功状态码，但是没有响应体
206 Partial Content 是应用于HTTP分块下载或断点续传，表明响应体的数据只是部分数据

301 Moved Permanently 永久重定向
302 Found 临时重定向
 这两个重定向的响应头会有Location字段，存储了要跳转的URL，浏览器会自动跳转到这个URL
304 Not Modified 资源未修改，表明可以继续使用缓存资源

400 Bad Request 表明客户端请求有误
403 Forbidden 表明禁止访问该资源
404 Not Found 资源不存在

500 Internal Server Error 服务器错误
501 Not Implemented 请求未实现
502 Bad Gateway 网关正常，但是逻辑服务器出问题了
503 Service Unavailable 服务器繁忙
```

http和https的区别
https在http和与TCP层之间增加了`SSL/TLS`协议，提供了以下能力：
- 信息加密
- 验证机制
- 身份证书

https采用了对称加密和非对称加密结合**混合加密**方式：
- 在通信建立前采用非堆成加密方式交换**会话密钥**，后续就不再使用非对称加密。
- 在通信过程中全部使用对称加密的会话密钥来加密明文数据。

TLS协议建立的流程
1. 客户端向服务器发起加密通信请求
   - 客户端支持的TLS协议版本
   - 客户端产生的随机数，用于后面生成会话密钥
   - 客户端支持的加密算法
2. 服务端响应请求
   - 确认TLS协议版本
   - 服务器产生的随机数，也用于后面生成会话密钥
   - 服务器的数字证书
   - 确认加密算法
3. 客户端收到回应后，会确认证书的真实性，如果没有问题就从证书内取出公钥，然后用它加密报文
   - 一个随机数`pre-master key`，也用于后面生成会话密钥
   - 加密通信算法改变通知，表示后面的信息都将用会话密钥加密通信
   - 客户端握手结束通知，同时将之前的历史信息生成hash，供服务端校验
4. 根据之前的三个随机数以及商量的加密算法生成会话密钥
   - 加密通信算法改变通知，表示后面的信息都将用会话密钥加密通信
   - 服务端握手结束通知，同时将之前的历史信息生成hash，供服务端校验


script标签和link标签常用属性
link标签：
```
href 指定资源地址
rel 定义当前文档与链接指向资源的关系
  stylesheet
  icon
  preload / prefetch 资源预加载
  noopner / noreferrer 安全相关
as 指定预加载资源的类型(用于preload / prefetch)
  script, style, font, image, fetch
```

preload预先加载如css，字体，图片等资源
prefetch：预获取未来可能需要的资源，如后面页面可能用到的资源

当浏览器解析html时遇到preload资源提示时，会将相关内容放入**高优先级下载队列**，然后继续解析html

使用：
```html
<link rel="preload" href="main.css" as="style">
...
<link rel="stylesheet" href="main.css"> <!-- 这里会直接使用预加载的资源 -->
```

script标签：
```
基本属性
src 指定外部脚本的URL
type 指定脚本的MIME类型
  text/javascript 默认
  module ES6模块
  application/json JSON数据
加载控制属性
async 异步加载脚本，下载时不阻塞html解析，执行时阻塞
defer 延迟加载脚本，html解析完成后按顺序执行
```
defer和async都会让脚本异步下载，区别在于defer在html解析完成(DOMContentLoaded)后执行，defer在脚本下载完后马上执行，会阻塞html解析。