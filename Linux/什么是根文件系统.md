### 什么是根文件系统？

想要回答这个问题，我们首先要明白，什么是文件系统(file system)。

想要了解文件系统，我们要对我们的存储设备有一个认识：即我们的存储设备是一个巨大的，存储字节的数组，无论是固态硬盘还是机械硬盘亦或者其他存储设备都是这样。
对存储设备而言，是没有文件这个概念的，文件只不过是这个字节数组中一段连续的区域所存储的数据。而要形成文件，就还需要文件系统的帮忙。文件系统也是一个程序，
是他向内核实现了文件的概念以及相关的服务，当内核需要读或者写某个文件的时候都是通过文件系统来完成的。

文件系统通过将这些连续的区域组织成特定的结构，并在其他区域写入这些区域的地址作为索引来实现文件管理。

而根文件系统，是内核启动之后加载的第一个文件系统，可以是基于内存的文件系统，也可以是基于类似磁盘的文件系统。需要明白的是，在系统的不同阶段有不同的根文件系统。
当内核刚启动的时候系统引导程序会挂载(mount)一个基于内存的文件系统在根目录上，我们称之为initramfs，他是第一个根文件系统，这个文件系统里面存储了init程序和
一些设备的驱动程序以及类似busybox之类的应用程序。init是一个永远不会退出的程序，他是内核启动的第一个进程，他负责启动系统的其他程序，如果这个进程意外退出了，
就会引起kernel panic。这个文件系统的其他程序还会自动为安装各类设备的驱动，如硬盘的驱动，有了硬盘的驱动，我们就可以访问硬盘的数据，
这意味这我们可以舍弃当前的根文件系统，进而将硬盘某个的文件系统挂载进系统根目录，作为新的根文件系统。这个过程通过(pivot_root)这个系统调用来完成。

一般而言，执行init之后便创建了一个shell环境，可以通过系统接口使用系统的所有功能。

### 为什么需要基于内存的根文件系统？
到目前为止，存储设备多种多样，而访问这些不同的存储设备又需要不同的驱动，而不同的存储设备又使用不同的文件系统类型，想要将某一种存储设备作为根文件系统，
内核除了需要有相应的驱动外，还需要对应文件系统的实现，这就会使内核过于臃肿(需要将这些驱动编译进内核)，不利于传播和使用。基于这个原因，我们使用基于内存
的根文件系统作为临时的根文件系统，我们可以将系统启动所需的硬件驱动放在这里，如硬盘驱动。当进入到这个临时的根文件系统我们就可以将这些驱动安装进内核，访问相应的硬件，
如硬盘，之后就可以挂在硬盘的文件系统作为根目录文件系统。

根文件系统存在的最大意义在于让内核在某个文件中找到某个执行程序然后义无反顾的执行下去，在此过程中挂载其他的文件系统。

### 自制根文件系统
根文件系统中最重要的程序就是init程序，我们可以自己实现一个init程序。创建 custom-rootfs 目录，然后创建 init.c 文件，写入以下代码：
```c
#include <stdio.h>
#include <unistd.h>

int main(int argc, char *argv[]) {
  char cmd[100];
  sleep(1);

  while(1) {
    printf("Input Cmd: ");
    scanf("%s", cmd);
    sleep(1);
    printf("%s Cmd Result Is: xxx.\n", cmd);
    puts("");
  }
}
````

使用 gcc -Og -o init init.c --static 静态编译出 init程序

然后在当前目录使用 `find . | cpio -H newc -ov | gzip -9 > ../custom-rootfs.gz` 将该目录内容归档。

qemu中挂载这个 custom-rootfs:
```Makefile
.PHONY: all

all:
  qemu-system-x86_64 -m 1024 \
              -nographic \
              -kernel ./bzImage \
              -initrd ./diy-initrd.gz \
              --append "rdinit=/init console=ttyS0"


```
